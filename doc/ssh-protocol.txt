Reverse-Engineered Protocol for the Surface Serial Hub (SSH) Interface
================================================================================

Description: Documentation for the reverse-engineered SSH protocol.
Devices:     All devices with SAM-over-SSH type communication.
Date:        2020-04-11


The Surface Serial Hub (SSH) is the central communication interface for the
embedded Surface Aggregator Module controller (SAM or EC) on newer Surface
generations. We will refer to this protocol and interface as SAM-over-SSH,
as opposed to SAM-over-I2C/SAM-over-HID for the older generations.

On Surface devices with SAM-over-SSH, SAM is connected to the host via UART
and defined in ACPI as device with HID MSHW0084. On these devices,
significant functionality is provided via SAM, including access to battery
and power information and -events, thermal read-outs and -events, and many
more. For Surface Laptops, keyboard input is handled via HID directed
through SAM, on the Surface Laptop 3 this also includes touchpad input.

Note that the standard disclaimer for this project also applies to this
document: All of this has been reverse-engineered and may thus be erroneous
and/or incomplete.

All CRCs used in the following are two-byte `crc_ccitt_false(0xffff, ...)`.
All multi-byte values are little-endian.


Top-Level Protocol: Definitions
--------------------------------------------------------------------------------

The fundamental communication unit of the SSH protocol is a frame. A frame
consists of the following fields, packed together and in order:

    Field   Type   Description
    ------------------------------------------------------------------------
    TYPE    u8     Type identifier of the frame.
    LEN     u16    Length of the payload associated with the frame.
    SEQ     u8     Sequence ID (see explanation below).

Each frame structure is followed by a CRC over this structure. If the frame
has a payload (LEN > 0), the CRC over the frame structure (TYPE, LEN, and
SEQ fields) is placed directly after the frame structure and before the
payload. The payload is followed by its own CRC (over all payload bytes).
The LEN field does not include any of the CRCs, it equals the number of
bytes inbetween the CRC of the frame and the CRC of the payload.

Additionally, the following fixed two-byte sequences are used:

    Name   Value          Description
    ------------------------------------------------------------------------
    SYN    [0xAA, 0x55]   Synchronization bytes.
    TER    [0xFF, 0xFF]   Termination bytes.

A message consists of SYN, followed by the frame (TYPE, LEN, SEQ and CRC)
and, if specified in the frame (i.e. LEN > 0), payload (plus CRC). TER is
only used by the party ending the exchange, following the last message. The
messages corresponding to an exchange are identified by having the same
sequence ID (SEQ), stored inside the frame.

A frame can have the following types:

    Name         Value   Short Description
    ------------------------------------------------------------------------
    ERR          0x04    Sent on error in previously received message.
    ACK          0x40    Sent to acknowledge receival of DATA frame.
    DATA         0x80    Sent to transfer data.
    DATA_NOACK   0x00    Same as DATA, but does not need to be ACKed.

Both ERR- and ACK-type frames are used to control flow of messages and thus
do not carry a payload. DATA- and DATA_NOACK-type frames on the other hand
must carry a payload. The flow sequence and interaction of different frame
types will be described in more depth in the next section.


Top-Level Protocol: Flow Sequence
--------------------------------------------------------------------------------

Each exchange begins with SYN, followed by a DATA- or DATA_NOACK-type frame,
followed by its CRC, payload, and payload CRC. In case of a DATA_NOACK-type
frame, the exchange is then finished. No TER sequence is sent after the
DATA_NOACK-type frame. In case of a DATA-type frame, the receiving party has
to acknowledge receival of the frame by responding with a message containing
an ACK-type frame with the same sequence ID of the DATA frame. In other
words, the sequence ID of the ACK frame specifies the DATA frame to be
acknowledged. The receiving party then terminates the exchange by following
the ACK-type frame and its CRC with the TER byte sequence. In case of an
error, e.g. an invalid CRC, the receiving party responds with a message
containing an ERR-type frame. As the sequence ID of the previous data frame,
for which an error is indicated via the ERR frame, cannot be relied upon,
the sequence ID of the ERR frame should not be used and is set to zero.
After receival of an ERR frame, the sending party should re-send all
outstanding (non-ACKed) messages.

An example exchange might look like this:

    tx: -- SYN FRAME(DATA) CRC PAYLOAD CRC ---------------------------------
    rx: ---------------------------------- SYN FRAME(ACK) CRC TER ----------

where both frames have the same sequence ID (SEQ). In case of an error, the
exchange would look like this:

    tx: -- SYN FRAME(DATA) CRC PAYLOAD CRC ---------------------------------
    rx: ---------------------------------- SYN FRAME(ERR) CRC TER ----------

upon which the sender should re-send the message. Note that the sequence ID
of the ERR-type frame is fixed to zero. For DATA_NOACK-type frames, both
exchanges are the same:

    tx: -- SYN FRAME(DATA_NOACK) CRC PAYLOAD CRC ---------------------------
    rx: --------------------------------------------------------------------

Here, an error can be detected, but not corrected or indicated to the
sending party. These exchanges are symmetric, i.e. switching rx and tx
results again in a valid exchange. Currently, no longer exchanges are known.


Commands: Requests, Responses, and Events
--------------------------------------------------------------------------------

Commands are sent as payload inside a data frame. Currently, this is the
only known payload type of DATA frames, with a payload-type value of 0x80.

The command-type payload consists of an eight-byte command structure,
followed by optional and variable length command data. The length of this
optional data is derived from the frame payload length given in the
corresponding frame, i.e. it is `frame.len - sizeof(struct ssh_command)`.
The command struct contains the following fields, packed together and in
order:

    Field       Type   Description
    ------------------------------------------------------------------------
    TYPE        u8     Type of the payload. For commands always 0x80.
    TC          u8     Target category.
    PRI (in)    u8     Priority for incoming (EC to host) commands.
    PRI (out)   u8     Priority for outgoing (host to EC) commands.
    IID         u8     Instance ID.
    RQID        u16    Request ID.
    CID         u8     Command ID.

The command struct and data, in general, does not contain any failure
detection mechanism (e.g. CRCs), this is solely done on the frame level.

Command-type payloads are used by the host to send commands and requests to
the EC as well as by the EC to send responses and events back to the host.
We differentiate between requests (sent by the host), responses (sent by the
EC in response to a request), and events (sent by the EC without a
preceeding request).

Commands and events are uniquely identified by their target category (TC)
and command ID (CID). The target category specifies a general category for
the command (e.g. system in general, vs. battery and ac, vs. temperature,
and so on), while the command ID specifies the command inside that
category. Only the combination of TC+CID is unique. Additionally, commands
have an instance ID (IID), which is used to differentiate between different
sub-devices. For example TC=3 CID=1 is a request to get the temperature on
a thermal sensor, where IID specifies the respective sensor. If the
instance ID is not used, it should be set to zero. If instance IDs are
used, they, in general, start with a value of one, whereas zero may be used
for instance independent queries, if applicable. A response to a request
should have the same target category, command ID, and instance ID as the
corresponding request.

Responses are matched to their corresponding request via the request ID
(rqid) field. This is a 16 bit counter similar to the sequence ID on the
frames. Note that the sequence ID of the frames for a request-response pair
does not match. Only the request ID has to match. Frame-protocol wise these
are two separate exchanges, and may even be separated, e.g. by an event
being sent after the request but before the response.

Events are identified by unique and reserved request IDs. These IDs should
not be used by the host when sending a new request. They are used on the
host to, first, detect events and, second, match them with a registered
event handler. Request IDs for events are chosen by the host and directed
to the EC when setting up and enabling an event source (via the
enable-event-source request). The EC then uses the specified request ID for
events sent from the respective source. Note that an event should still be
identified by its target category, command ID, and, if applicable, instance
ID, as a single event source can send multiple different event types. In
general, however, a single target category should map to a single reserved
event request ID.

Furthermore, requests, responses, and events have an associated priority
(PRI). This priority is split into output (host to EC) and input (EC to
host) fields, with the respecting other field (e.g. output field on
incoming messages) set to zero. Two priorities are known: Normal priority
(0x01) and high priority (0x02). In general, the response to a request
should have the same priority value, however, the field (output vs. input)
should be used in accordance to the direction in which the response is sent
(i.e. on the input field, as responses are generally sent from the EC to
the host).

Note that, even though requests and events should be uniquely identifiable
by target category and command ID alone, the EC may require specific
priority and instance ID values to accept a command. A command that is
accepted at normal priority, for example, may not be accepted at high
priority and vice versa.
