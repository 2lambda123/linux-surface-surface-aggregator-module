From 7f77252fac8fcdaa853e1fb78bfca29e3e786333 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sat, 31 Oct 2020 19:48:06 +0100
Subject: [PATCH 5/6] PCI: Update platform power state when updating PCI state

On some devices and platforms, the initial platform power state is not
in sync with the power state of the PCI device.

Specifically, on the Surface Book 2 and 3, some ACPI power regions that
should be "on" for the D0 state (and others) are initialized as "off" in
ACPI, whereas the PCI device is in D0. As the state is updated in
pci_enable_device_flags() without ensuring that the platform state is
also updated, the power resource will never be properly turned on.
Instead, it lives in a sort of on-but-marked-as-off zombie-state, which
confuses things down the line when attempting to transition the device
into D3cold: As the resource is already marked as off, it won't be
turned off and the device does not fully enter D3cold, causing increased
power consumption during (runtime-)suspend.

Ensuring that the platform power state is in sync with the PCI power
state when updating the latter guarantees that all required ACPI power
regions are powered on/off in accordance with the requirements
(specified in the ACPI _PRn fields) for the current PCI power state.

Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
---
 drivers/pci/pci.c | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 15566ec8f75d..6839053db5a5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1663,7 +1663,7 @@ static void pci_enable_bridge(struct pci_dev *dev)
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 {
 	struct pci_dev *bridge;
-	int err;
+	int err = 0;
 	int i, bars = 0;
 
 	/*
@@ -1673,9 +1673,35 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 	 * (e.g. if the device really is in D0 at enable time).
 	 */
 	if (dev->pm_cap) {
+		pci_power_t current_state;
 		u16 pmcsr;
+
 		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
-		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+		current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+
+		/*
+		 * On some platforms, the initial power state may not be in
+		 * sync with the PCI power state. Specifically, on ACPI based
+		 * platforms, power-resources for the current state may not
+		 * have been properly enabled (or power-resources not required
+		 * for the current state disabled) yet. Thus, ensure that the
+		 * platform power state reflects the PCI state.
+		 *
+		 * Update platform state before actually setting current state
+		 * so that it can still be accessed in platform code, if
+		 * necessary.
+		 */
+		if (platform_pci_power_manageable(dev))
+			err = platform_pci_set_power_state(dev, current_state);
+
+		// always update current state
+		dev->current_state = current_state;
+
+		if (err) {
+			pci_err(dev, "failed to update platform power state: %d\n",
+				err);
+			return err;
+		}
 	}
 
 	if (atomic_inc_return(&dev->enable_cnt) > 1)
-- 
2.29.2

